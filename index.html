<!DOCTYPE html>
<html>
<head>
<title>Student Details</title>
</head>
<body>
    <a href = "bonus.html">BONUS</a>
<h1>Muralidhar Reddy kalla</h1>
<h2>My favorite place -- TajMahal,India</h2>
<p>The Taj Mahal is reminder of the Mughal era as it was built by<b> Mughal Emperor Shah Jahan</b> back in
 the <b>17th century</b>. A visit to the Taj Mahal takes me back in time to that magical era giving my mind a
 virtual break from the current times.</p>
 <hr>
<h2>Directions to TajMahal from Maryville</h2>
<ol><li>Go to kansas city Airport.</li>
    <li>Board Flight to Delhi,India.<ol>
        <li>Board connecting flight to Agra Airport.</li>
        <li>Hire a taxi to TajMahal.</li></ol></li></ol>
</ol>
<ul><li>A Good Camera</li>
    <li>Selfie Stick</li>
    <li>Food</li>
</ul>
<a href ="aboutme.html">Visit aboutme file</a>
<hr>
<h2>Popular Food/Drinks</h2>
<p>The table below illustrates about the best food/Drinks in various parts in the world and their price
     in dollars.</p>
     <table>
         <tr>
             <th>Food/Drinks</th>
             <th>Location</th>
             <th>Price($)</th>
         </tr>
         <tr>
             <td>Biryani</td>
             <td>Hyderabad</td>
             <td>10</td>
             <tr>
                <td>Momos</td>
                <td>Sikkim</td>
                <td>15</td>  
      </tr>
                <td>Dosa</td>
                <td>Karnataka</td>
                <td>7</td>  
      </tr>
                <td>Dhokla</td>
                <td>Gujarath</td>
                <td>5</td>  
      </tr>

     </table>
<hr>
<h2>Code Display</h2>     
<blockquote cite ="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search (BFS) is an
    algorithm for searching a tree data structure for a node that satisfies a given property.It starts
    at the tree root and explores all nodes at the present depth prior to moving on to the nodes at the 
    next depth level.</blockquote>
    <a href ="https://en.wikipedia.org/wiki/Breadth-first_search">Source Link</a>
    <pre>vector<vector<int>> adj;  // adjacency list representation
        int n; // number of nodes
        int s; // source vertex
        queue<int> q;
        vector<bool> used(n);
        vector<int> d(n), p(n);
        q.push(s);
        used[s] = true;
        p[s] = -1;
        while (!q.empty()) {
            int v = q.front();
            q.pop();
            for (int u : adj[v]) {
                if (!used[u]) {
                    used[u] = true;
                    q.push(u);
                    d[u] = d[v] + 1;
                    p[u] = v;
                }
            }
        }
    </pre>
</body>
</html>
